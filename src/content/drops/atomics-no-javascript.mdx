---
templateKey: drop-post
title: Atomics no JavaScript
slug: atomics-no-javascript
featured:
  - https://res.cloudinary.com/beto-muniz/image/upload/f_auto/v1599422987/Titulo_Image_1_krcacc.jpg
description: Neste drop falo sobre o objeto Atomics, um recurso bem Ãºtil para
  controlar race conditions ao se trabalhar com abordagens possÃ­veis de
  multi-threading do JavaScript.
date: 2020-09-08T19:49:54.643Z
keywords:
  - multi-threading
  - javascript
  - atomics
audiencecall: Oi pessoal, beleza?
informaldesc: ğŸ˜‹  No drop de hoje falei sobre Atomics, um recurso bem bacana
  para controlar race conditions ao se trabalhar com abordagens possÃ­veis de
  multi-threading do JavaScript, como SharedArrayBuffer que comentei ontem.
  Espero que gostem.
category: tech
lang: pt
external: false
---
import { Drop } from '../../components/mdx'

<Drop>

ğŸ’¥ Com o advento de algumas [abordagens multi-threading do JavaScript](https://betomuniz.com/drops/sharedarraybuffer-no-javascript), um problema comum desse tipo de cenÃ¡rio surgiu, as _race conditions_.

ğŸ‘‰ **race conditions** basicamente sÃ£o resoluÃ§Ãµes desordenadas de operaÃ§Ãµes paralelas, que por sua vez, necessitam ser ordenadas para correto funcionamento, em geral, dependentes entre si. 

âš¡ï¸ O objeto **Atomics** surge no JavaScript justamente para nos permitir controlar a ordem que queremos que operaÃ§Ãµes paralelas sejam resolvidas e assim garantir a intergidade dos dados resultantes.  

ğŸ© No exemplo abaixo da biblioteca [sleep-synchronously](https://github.com/sindresorhus/sleep-synchronously/blob/master/index.js#L4), qualquer operaÃ§Ã£o que estiver acontecendo em paralelo serÃ¡ imediatamente pausada por 1 segundo aguardando a resoluÃ§Ã£o da declaraÃ§Ã£o `Atomics.wait`. 

```javascript
// ... 

Atomics.wait(
  new Int32Array(new SharedArrayBuffer(4)), 
  0, 
  0, 
  1000
);

// ... 
```

ğŸ‘¨â€ğŸ’» Esse tipo de uso pode ser Ãºtil durante a escrita de testes. 

ğŸ‘¨â€ğŸ¨ Sensacional isso, nÃ©?

</Drop>